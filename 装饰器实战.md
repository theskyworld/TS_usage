## 装饰器实战

### 仿NestJS实战

#### 依赖注入

环境准备

- 安装第三方包：

  ```shell
  npm i express express-session --save
  npm i reflect-metadata --save
  ```

- src目录下创建以下目录

  - service业务逻辑层：处理各种业务底层逻辑
  - controller控制层：一个用于装饰器`@Controller`修饰的类，用来支持页面的各种请求，通过各种业务逻辑的接口访问各种业务逻辑
  - decorator装饰器层
    - `@Autowired`自动装配装饰器，帮助把外部其它数据注入到当前类的属性或者类方法的参数中
  - middleaware中间件层
  - router路由层
  - collection集合层（容器层）
  - utils工具包层
  - 启动文件：`app.ts`

- `dependencyId`/`injectId`：依赖的id，作为`@Autowired`装饰器的实参，以便在不同类中使用`@Autowired`装饰器时进行区分。例如，下面的`userServiceImplement`

- `singleton`：标记是否作为单例注入的参数

##### service业务逻辑层

```ts
//userServiceImplement.ts
export default class UserServiceImplement {
  constructor() {
    console.log("创建类UserServiceImplement的实例");
  }
  login(username: string, pwd: string, role: string): boolean {
    console.log("login进入service,username : ", username);
    if (username === "admin" && pwd === "123" && role === "admin") {
      return true;
    } else {
      return false;
    }
  }
  register() {
    console.log("UserService-register...");
  }
}
```

对于`UserServiceImplement`类，为了避免因多次使用`Autowired("userServiceImplement")`装饰器(多个装饰器修饰同一个对象时，自下而上执行)而导致`UserServiceImplement`类被实例化多次，采用单例模式：

```ts
//userServiceImplement.ts
export default class UserServiceImplement {
  //单例模式
  static userServiceImplement: UserServiceImplement;
  // 通过getInstance控制类实例的创建
  static getInstance(): UserServiceImplement {
    if (!this.userServiceImplement) {
      this.userServiceImplement = new UserServiceImplement();
    }
    return this.userServiceImplement;
  }
  constructor() {
    console.log("创建类UserServiceImplement的实例");
  }
  login(username: string, pwd: string, role: string): boolean {
    console.log("login进入service,username : ", username);
    if (username === "admin" && pwd === "123" && role === "admin") {
      return true;
    } else {
      return false;
    }
  }
  register() {
    console.log("UserService-register...");
  }
}
```

增加新功能：获取用户信息

```ts
//userServiceImplement.ts
export default class UserServiceImplement {
  // 增加UserDaoImplement类中的功能
  userInfoDaoImplement: UserDaoImplement = new UserDaoImplement();
  static userServiceImplement: UserServiceImplement;
  // 通过getInstance控制类实例的创建
  static getInstance(): UserServiceImplement {
    if (!this.userServiceImplement) {
      this.userServiceImplement = new UserServiceImplement();
    }
    return this.userServiceImplement;
  }
  constructor() {
    console.log("创建类UserServiceImplement的实例");
  }
  login(username: string, pwd: string, role?: string): Userinfo | null {
    console.log("login进入service,username : ", username);
    return this.userInfoDaoImplement.GetUserByUsername(username, pwd) || null;
  }
  register(username: string, pwd: string) {
    this.userInfoDaoImplement.GetUserByUsername(username, pwd);
    console.log("UserService-register...");
  }
}
```

```ts
//userDaoImplement.ts
import userinfosdb from "../userInfo";

export default class UserDaoImplement {
  public GetUserByUsername(username: string, pwd: string) {
    return userinfosdb.find((userinfo) => {
      return username === userinfo.username && pwd === userinfo.password;
    });
  }
}
```

`userServiceInterface.ts`：

```ts
// userServiceInterface.ts
import UserServiceImplement from "./userServiceImplement";

// UserServiceImplement实现类的接口
export default class UserServiceInterface {
  static getUserServiceImplement() {
    return UserServiceImplement;
  }
}
```

##### controller控制层

```ts
//userController.ts
import Autowired from "../decorator/autowiredDecorator";
import collectionInstance from "../collection";
import UserServiceInterface from "../service/userServiceInterface";
import UserServiceImplement from "../service/userServiceImplement";
class UserController {
  // 依赖注入装饰器,使用Autowired装饰器
  @Autowired("userServiceImplement")
  private userServiceImplement!: UserServiceInterface;

  public login(): void {
    // 从收集的实例中获取userService类的实例对象
    // const userServiceImplementInstance: 
UserServiceImplement =
    //   collectionInstance.get("userServiceImplement");

    // 或者从UserController的原型对象中获取
    const userServiceImplementInstance: UserServiceImplement =
      Reflect.getOwnPropertyDescriptor(
        UserController.prototype,
        "userServiceImplement"
      )?.value;

    userServiceImplementInstance.register();
  }
}

const userController = new UserController();
userController.login();
```

结合单例模式：

```ts
//userController.ts
import Autowired from "../decorator/autowiredDecorator";
import collectionInstance from "../collection";
import UserServiceInterface from "../service/userServiceInterface";
import UserServiceImplement from "../service/userServiceImplement";
class UserController {
  // 依赖注入装饰器,使用Autowired装饰器
  // true表示使用单例模式
  // 使用五次@Autowired装饰器，最终UserServiceImplement只会被实例化三次
  @Autowired("userServiceImplement", true)
  @Autowired("userServiceImplement", true)
  @Autowired("userServiceImplement")
  @Autowired("userServiceImplement")
  @Autowired("userServiceImplement", true)
  private userServiceImplement!: UserServiceInterface;

  public login(): void {
    const userServiceImplementInstance: UserServiceImplement =
      Reflect.getOwnPropertyDescriptor(
        UserController.prototype,
        "userServiceImplement"
      )?.value;

    userServiceImplementInstance.register();
  }
}

const userController = new UserController();
userController.login();
```

进行优化，将控制是否为单例模式的逻辑进行抽离，抽离到`@SingletonDecorator`装饰器中：

```ts
//userController.ts
class UserController {
  // 依赖注入装饰器,使用Autowired装饰器

  @Autowired("userServiceImplement")
  @Autowired("userServiceImplement")
  @Autowired("userServiceImplement")
  // 使用单例模式装饰器,与@Autowired装饰器结合使用，实现该装饰器的单例模式功能
  // 自下向上执行，先执行@SingletonDecorator装饰器，决定对于@Autowired装饰器，是走单例模式获取实例还是通过构造函数创建获取实例
  // true表示使用单例模式
  // 如果为true，以上的@Autowired装饰器代码将只调用一次UserServiceImplement类的构造函数
  // 反之，则将调用三次
  @SingletonDecorator(true)
  private userServiceImplement!: UserServiceInterface;

  public login(): void {
    const userServiceImplementInstance: UserServiceImplement =
      Reflect.getOwnPropertyDescriptor(
        UserController.prototype,
        "userServiceImplement"
      )?.value;

    userServiceImplementInstance.register();
  }
}
```

增加新功能：获取用户信息

```ts
//userController.ts
public login(): void {
    const userServiceImplementInstance: UserServiceImplement =
      Reflect.getOwnPropertyDescriptor(
        UserController.prototype,
        "userServiceImplement"
      )?.value;

    // userServiceImplementInstance.login("admin", "123");
    // 增加新功能：获取用户信息
    const userInfo: Userinfo = userServiceImplementInstance.login(
      "admin",
      "123"
    )!;
    console.log(userInfo);
    // {
    //   username: 'admin',
    //   password: '123',
    //   phone: '1111',
    //   role: 'admin',
    //   mark: '管理员'
    // }
  }
```



##### decorator装饰器层

```ts
// autowiredDecorator.ts
import "reflect-metadata";
import collectionInstance from "../collection";

type MyAttrDecorator = (
  targetClassPrototype: object,
  propKey: string | symbol
) => void;
export default function AutoWired(injectId: string): MyAttrDecorator {
  return (targetClassPrototype, propKey) => {
    const PropType = Reflect.getMetadata(
      "design:type",
      targetClassPrototype,
      propKey
    );
    const userServiceImplementInstance =
      new (PropType.getUserServiceImplement())();
    // console.log(propType);
    // const PropTypeInstance = new PropType();
    // 进行收集保存
    // collectionInstance.set(propKey, userServiceImplementInstance);
    // 优化收集保存
    // 将userServiceImplementInstance保存在目标类的原型上,作为一个原型对象属性的值进行保存
    // 而不是保存在collectionInstance中
    // 避免在存储时因propKey同名,而造成值被覆盖的问题
    Reflect.defineProperty(targetClassPrototype, propKey, {
      value: userServiceImplementInstance,
    });
  };
}
```

结合单例模式：

```ts
// autowiredDecorator.ts
import "reflect-metadata";
import collectionInstance from "../collection";
import UserServiceImplement from "../service/userServiceImplement";

type MyAttrDecorator = (
  targetClassPrototype: object,
  propKey: string | symbol
) => void;
export default function AutoWired(
  injectId: string,
  singleton?: boolean
): MyAttrDecorator {
  return (targetClassPrototype, propKey) => {
    const PropType = Reflect.getMetadata(
      "design:type",
      targetClassPrototype,
      propKey
    );
    const UserServiceImplement: UserServiceImplement =
      PropType.getUserServiceImplement();
    let userServiceImplementInstance;
    // 通过单例模式获取userServiceImplementInstance实例对象
    if (singleton) {
      userServiceImplementInstance = UserServiceImplement.getInstance();
      // 通过构造函数获取
    } else {
      userServiceImplementInstance = new UserServiceImplement();
    }
    Reflect.defineProperty(targetClassPrototype, propKey, {
      value: userServiceImplementInstance,
    });
  };
}

```

进行优化，将控制是否为单例模式的逻辑进行抽离，抽离到`@SingletonDecorator`装饰器中：

```ts
//singletonDecorator.ts
import "reflect-metadata";
import UserServiceImplement from "../service/userServiceImplement";
// 单例模式装饰器
// 用于实现@Autowired装饰器的单例模式功能
// 如果为单例模式，则获取userServiceImplementInstance实例对象时，
// 通过调用UserServiceImplement类中的getInstance方法来获取该类中单例模式下的实例对象
// 然后将该实例对象转交给@Aurowired装饰器（定义在元数据中）
// 否则，直接将获取到的UserServiceImplement类转交给@Aurowired装饰器，让其通过构造函数创建实例的方式来获取userServiceImplementInstance实例对象
type MyAttrDecorator = (
  targetClassPrototype: object,
  propKey: string | symbol
) => void;
export default function SingletonDecorator(
  isSingleton: boolean
): MyAttrDecorator {
  return (targetClassPrototype, propKey) => {
    const PropType = Reflect.getMetadata(
      "design:type",
      targetClassPrototype,
      propKey
    );
    const UserServiceImplement =
      PropType.getUserServiceImplement();

    const metaSingleton = Reflect.getMetadata(
      "singleton",
      targetClassPrototype,
      propKey
    );
    let userServiceImplementInstanceOrClass;
    // 通过单例模式获取userServiceImplementInstance实例对象
    if (isSingleton) {
      // metaSingleton中没保存
      if (!metaSingleton) {
        // 定义一个metaSingleton元数据，以便在@Autowired装饰器中控制是否为单例模式
        Reflect.defineMetadata(
          "singleton",
          isSingleton,
          targetClassPrototype,
          propKey
        );
        userServiceImplementInstanceOrClass =
          UserServiceImplement.getInstance();
      } else {
        console.log("单例模式，使用上一次创建的实例对象");
      }
      // 通过构造函数获取
    } else {
      userServiceImplementInstanceOrClass = UserServiceImplement;
    }
    // 将userServiceImplementInstanceOrClass实例对象或者类转交给@Autowired装饰器
    Reflect.defineMetadata(
      "userServiceImplementInstanceOrClass",
      userServiceImplementInstanceOrClass,
      targetClassPrototype,
      propKey
    );
  };
}
```

```ts
// autowiredDecorator.ts
import "reflect-metadata";
import collectionInstance from "../collection";
import UserServiceImplement from "../service/userServiceImplement";

type MyAttrDecorator = (
  targetClassPrototype: object,
  propKey: string | symbol
) => void;
export default function AutoWired(injectId: string): MyAttrDecorator {
  return (targetClassPrototype, propKey) => {
    let userServiceImplementInstance;
    // 获取SingletonDecorator装饰器中转交过来的数据
    const userServiceImplementInstanceOrClass = Reflect.getMetadata(
      "userServiceImplementInstanceOrClass",
      targetClassPrototype,
      propKey
    );
    // metaSingleton控制是否走单例模式
    // 来自于@SingletonDecorator装饰器中的定义（传递）
    const metaSingleton = Reflect.getMetadata(
      "singleton",
      targetClassPrototype,
      propKey
    );
    // 单例模式
    // userServiceImplementInstanceOrClass的值为一个实例对象
    if (metaSingleton) {
      console.log("单例模式获取");
      userServiceImplementInstance = userServiceImplementInstanceOrClass;
      // 构造函数创建
      // userServiceImplementInstanceOrClass的值为一个类
    } else {
      console.log("构造函数获取");
      userServiceImplementInstance = new userServiceImplementInstanceOrClass();
    }
    Reflect.defineProperty(targetClassPrototype, propKey, {
      value: userServiceImplementInstance,
    });
  };
}

```



##### middleaware中间件层

##### router路由层

##### collection集合层（容器层）

```ts
//index.ts
// 创建一个用于收集类实例对象的类
class CollectionInstanceOfClass<T = any> {
  static collection: CollectionInstanceOfClass =
    new CollectionInstanceOfClass();

  private containerMap = new Map<string | symbol, any>();

  private constructor() {
    // console.log("创建CollectionInstanceOfClass类的实例对象...");
  }
  private static test() {
    console.log("test...");
  }

  public set(id: string | symbol, value: T): void {
    this.containerMap.set(id, value);
  }
  public get(id: string | symbol): T {
    return this.containerMap.get(id);
  }
}
// 获取CollectionInstanceOfClass类的实例
const collectionInstance = CollectionInstanceOfClass.collection;
export default collectionInstance;

```

##### utils工具包层

#### 控制器装饰器

环境搭建：

- 安装包：

  ```shell
  npm i @types/express -D
  ```

- 配置`package.json`文件

  ```json
    "scripts": {
      "app": "nodemon --watch src/ -e ts --exec ts-node ./src/expressapp.ts",
      "ctrl": "ts-node src/controller/homeController.ts"
    },
  ```

编写工具类

```ts
//sessionUtil.ts
import { Request } from "express";
export function getSession(req: Request) {
  return (req as any).session;
}
```

```ts
//routerUtil.ts
import { Router } from 'express';
export const router: Router = Router();
```

##### 实现`login`

`userController.ts`

```ts
import {
  AutoWired,
  ControllerDecorator,
  SingletonDecorator,
  get as GetDecorator,
} from "../decorator";
import { UserServiceInterface } from "../service";
import { Request, Response } from "express";

@ControllerDecorator("/")
class UserController {
  @AutoWired("userServiceImplement")
  @AutoWired("userServiceImplement")
  @AutoWired("userServiceImplement")
  @SingletonDecorator(true)
  private userServiceImplement!: UserServiceInterface;

  @GetDecorator("/login")
  public login(req: Request, res: Response): void {
    const htmlStr = `<div><form method="post" 
    action = "/loginprocess"><div>用户d名: 
    <input type='text' name = 'username'/> </div><div>
     密码: <input type='password' name = 'pwd'/> </div>
     <div><input type="submit" value = "提交" /> </div>
     </form></div>`;
    res.send(htmlStr);
  }
}

const userController = new UserController();
// userController.login();
```

装饰器

```ts
//controllerDecorator.ts
import { router } from "../utils/routerUtil";

export  function ControllerDecorator(reqRootPath? : string) {
    return function (targetClass: any) {
        for (let methodName in targetClass.prototype) {
            const reqPath = Reflect.getMetadata('path', targetClass.prototype, 'login');
            const reqMethodHandler = targetClass.prototype[methodName];
            router.get(reqPath, reqMethodHandler);
       }
     } 
}
```

```ts
//reqMethodsDecorators.ts
import "reflect-metadata";

type MyMethodDecoratorType = (
  targetClassPrototype: any,
  methodName: string,
  methodDecoription: PropertyDescriptor
) => void;

// get请求
export function get(reqPath: string): MyMethodDecoratorType {
  return function (targetClassPrototype, methodName, methodDecoription) {
    console.log("进入get请求方法装饰器。path:", reqPath);
    const targetClas = targetClassPrototype.constructor;
    const targetClasInstance = new targetClas();
    Reflect.defineMetadata("path", reqPath, targetClassPrototype, methodName);
  };
}
```

启动文件：`src/app.ts`

```ts
import "reflect-metadata";
import express from "express";
import session from "express-session";

// 引入控制器ts文件,会自动执行HomeController文件中方法装饰器@get和类装饰器@Controller
// 因为装饰器在/router/controlldecorators 这个文件中,
// 这一执行直接导致router增加了路由完成，就是controlldecorators的第S100行代码的执行
import "./controller/userController";
//import './controller/RightsController'

// 然后在引入路由器
import { router } from "./utils/routerUtil";

//Express4.16+已经在express包中加入了bodyParser,可直接作为express的方法使用.
const app = express(); //Creates an Express application.

// 设置session关联的cookie信息
app.use(
  session({
    secret: "cookeid12345",
    name: "cookieinfo",
    resave: false,
    saveUninitialized: true,
  })
);

//   Express4.16+后的 处理表单数据 url 集成到了express框架中
app.use(express.urlencoded({ extended: false })); ////处理表单数据 url
app.use(router); //添加路由到express应用对象-app对象中

let server = app.listen(8888, function () {
  console.log("node服务器启动,端口8888"); //服务启动完成,输出日志
});

```

##### 实现`loginProcess`

`userController.ts`

```ts
import {
  AutoWired,
  ControllerDecorator,
  SingletonDecorator,
  get as GetDecorator,
  post as PostDecorator,
} from "../decorator";
import { UserServiceImplement, UserServiceInterface } from "../service";
import { Request, Response } from "express";
import { getSession } from "../utils/sessionUtil";
import { Userinfo } from "../userInfo";

@ControllerDecorator("/")
class UserController {
  @AutoWired("userServiceImplement")
  @SingletonDecorator(true)
  private userServiceImplement!: UserServiceInterface;

  @GetDecorator("/login")
  login(req: Request, res: Response): void {
    const htmlStr = `<div><form method="post" 
    action = "/loginprocess"><div>用户名: 
    <input type='text' name = 'username'/> </div><div>
     密码: <input type='password' name = 'pwd'/> </div>
     <div><input type="submit" value = "提交" /> </div>
     </form></div>`;
    res.send(htmlStr);
  }
  @PostDecorator("/loginprocess")
  loginProcess(req: Request, res: Response): void {
    console.log("loginprocess=this:", this);
    let session = getSession(req);

    let userServiceImplement: UserServiceImplement =
      Reflect.getOwnPropertyDescriptor(
        UserController.prototype,
        "userServiceImplement"
      ).value; //S100
    let userinfosdb: Userinfo = userServiceImplement.login(
      req.body.username,
      req.body.pwd
    );
    if (userinfosdb && userinfosdb.username) session.userinfosdb = userinfosdb;
    // 基础复习：req.send只能发送一次,如果想发送多次,就必须使用res.write
    res.setHeader("Content-Type", "text/html;charset=UTF-8");
    let outputhtml = "";
    if (userinfosdb.role === "admin") {
      outputhtml += `<div>管理员:${userinfosdb.role}</div>`;
      outputhtml += `<div><a href="/rightsmanager">进入管理员权限页面</a></div>`;
    }
    res.write(outputhtml);
    res.write(`<div>登录成功,欢迎你:${userinfosdb.username}</div>`);
    res.write(`<div><a  href="/login">进入首页</a></div>`);
    res.end();
  }
}
```

装饰器

```ts
// controllerDecorator.ts
import "reflect-metadata";
import { router } from "../utils/routerUtil";
type MethodType = "get" | "post";
type MyClassDecorator = <T extends { new (...args: any): any }>(
  targetClass: T
) => any;
export function ControllerDecorator(reqRootPath?: string): MyClassDecorator {
  return function (targetClass: any) {
    for (let methodName in targetClass.prototype) {
      // 获取请求路径和请求类型元数据
      const reqPath = Reflect.getMetadata(
        "path",
        targetClass.prototype,
        methodName
      );

      const reqType: MethodType = Reflect.getMetadata(
        "methodType",
        targetClass.prototype,
        methodName
      );
        
      const reqMethodHandler = targetClass.prototype[methodName];
      // router.get(reqPath, reqMethodHandler);
      if (reqPath && reqType) {
        router[reqType](reqPath, reqMethodHandler);
      }
    }
  };
}

```

```ts
// reqMethodsDecorators.ts
import "reflect-metadata";

type MyMethodDecoratorType = (
  targetClassPrototype: any,
  methodName: string,
  methodDecoription: PropertyDescriptor
) => void;

function RequestDecorator(methodType: string) {
  return function (reqPath: string): MyMethodDecoratorType {
    return function (targetClassPrototype, methodName, methodDecoription) {
      console.log("进入get请求方法装饰器。path:", reqPath);
      const targetClas = targetClassPrototype.constructor;
      const targetClasInstance = new targetClas();
      // 定义请求路径和请求类型元数据
      Reflect.defineMetadata("path", reqPath, targetClassPrototype, methodName);
      Reflect.defineMetadata(
        "methodType",
        methodType,
        targetClassPrototype,
        methodName
      );
    };
  };
}

// get请求
export const get = RequestDecorator("get");
// post请求
export const post = RequestDecorator("post");
```



#### 中间件装饰器

##### 创建权限控制器类

```ts
// rightsController.ts
// 权限控制器
// 权限控制器
import { Request, Response } from "express";
import { get, ControllerDecorator as Controller } from "../decorator/index";



@Controller("/")
export default class RightsControllers {
  
  @get("/rightsmanager")
  rightsShow(req: Request, res: Response) {
    console.log("rightShow");
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    res.write("管理员权限页面");
    res.write("<a href='javascript:history.back()'>返回</a>");
    res.send();
  }
}
```

##### `userController`控制器中增加自动跳转首页或登录页面的功能

输入`"/"`路径时进入首页或者登录页面

```ts
//增加以下方法
@GetDecorator("/")
  index(req: Request, res: Response): void {
    // 如果用户登录
    if (getSession(req).userinfosdb) {
      let htmlstr = `<div><a href='/searchFoodHistory'
       style='text-decoration:none;color:red'> 搜索美食历史信息 </a></div><div><a href = '/orderInfo'  style='text-decoration:none;color:red'> 订单信息 </a></div><div><a href="/loginout" style='text-decoration:none;color:red'>注销</a></div>`;
      res.send(htmlstr);
      // 用户未登录
    } else {
      res.redirect("/login");
    }
  }
```

##### 增加中间件装饰器

```ts
//middleWareDecorator.ts
// 中间件装饰器
import { RequestHandler } from "express";
import "reflect-metadata";
export function middleWareDecorator(middleware: RequestHandler) {
  return function (targetPrototype: any, methodname: string) {
    Reflect.defineMetadata(
      "middlewares",
      middleware,
      targetPrototype,
      methodname
    );
  };
}
```

创建用于判断当前用户是否合法的中间件函数：

```ts
// middleWare.ts
// 中间件函数
import { Request, Response, NextFunction } from "express";
import { getSession } from "../utils/sessionUtil";

// 用于判断当前用户是否合法
export const isValidUser = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.log("执行isValidUser...");
  let session = getSession(req);
  // 非合法用户，不允许访问
  if (session.userinfosdb && session.userinfosdb.mark === "noallowlogin") {
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    res.write("您是被禁人士，被限制访问");
    res.end();
    // 允许访问
  } else {
    // 如果存在下一个中间件函数或者其它函数，则执行
    // 否则跳转到目标页面
    next();
  }
};

```

增加对应的被修饰控制类

```ts
// foodController.ts
import { Request, Response } from "express";
import {
  get,
  middleWareDecorator as middleware,
  ControllerDecorator as Controller,
} from "../decorator";
import { isValidUser } from "../middleaware/middleWare";
@Controller("/")
class FoodController {
  @get("/showFood")
  // 使用中间件装饰器，执行isValidUser中间件函数的逻辑，用于判断用户是否合法
  // 执行完之后执行@get装饰器，进行路由的跳转，然后执行showFood展示页面中的内容
  @middleware(isValidUser)
  showFood(req: Request, res: Response): void {
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    res.write("大混沌");
    res.write("一锅炖");
    res.end();
  }
}

```

在`controllerDecorator`装饰器中增加是否走中间件的逻辑

```ts
  //controllerDecorator.ts
// 获取中间件函数
      const middleWareFunc: RequestHandler = Reflect.getMetadata(
        "middlewares",
        targetClass.prototype,
        methodName
      );
      if (reqPath && reqType) {
        // 如果使用了中间件装饰器
        // 走中间件函数的逻辑
        if (middleWareFunc) {
          // 先执行middleWareFunc，再执行reqMethodHandler
          router[reqType](reqPath, middleWareFunc, reqMethodHandler);
          // 不走中间件
        } else {
          router[reqType](reqPath, reqMethodHandler);
        }
      }
```

##### 增加多个中间件装饰器

增加第二个中间件函数

```ts
// middleWare.ts
//...
// 第二个中间件函数
export const SecondMiddleAware = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.log("第二个中间件函数....");
  next();
};
```

优化中间件装饰器，实现能够执行多个中间件函数

```ts
export function middleWareDecorator(middleware: RequestHandler) {
  return function (targetPrototype: any, methodname: string) {
    // 使用该中间件装饰器执行第一个中间件函数时
    // let middlewares = Reflect.getMetadata(
    //   "middlewares",
    //   targetPrototype,
    //   methodname
    // );
    // if (!middlewares) {
    //   middlewares = [];
    // }

    const middlewares =
      Reflect.getMetadata("middlewares", targetPrototype, methodname) || [];
    // 将每次的middleware中间件函数假如middlewares数组中
    middlewares.push(middleware);
    // 将middlewares定义在元数据上
    Reflect.defineMetadata(
      "middlewares",
      middlewares,
      targetPrototype,
      methodname
    );
  };
}
```

对应地修改`controllerDecorator`装饰器

```ts
// controllerDecorator.ts
// 获取中间件函数
      // 当存在多个中间件函数执行时，获取的是一个中间件函数数组
      const middleWareFuncs: RequestHandler[] = Reflect.getMetadata(
        "middlewares",
        targetClass.prototype,
        methodName
      );
      // if (reqPath && reqType) {
      //   router[reqType](reqPath, reqMethodHandler);
      // }
      if (reqPath && reqType) {
        // 如果使用了中间件装饰器
        // 走中间件函数的逻辑
        if (middleWareFuncs) {
          // 先解构middleWareFuncs，执行多个中间件函数，再执行reqMethodHandler
          router[reqType](reqPath, ...middleWareFuncs, reqMethodHandler);
          // 不走中间件
        } else {
          router[reqType](reqPath, reqMethodHandler);
        }
      }
```

增加执行第二个中间件函数的中间件装饰器

```ts
// foodController.ts
  @get("/showFood")
  @middleware(SecondMiddleAware)
  @middleware(isValidUser)
  showFood(req: Request, res: Response): void {
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    res.write("大混沌");
    res.write("一锅炖");
    res.end();
  }
```

#### 路由器参数

```ts
// foodController.ts
import { Request, Response } from "express";
import {
  get,
  middleWareDecorator as middleware,
  ControllerDecorator as Controller,
} from "../decorator";
import { isValidUser, SecondMiddleAware } from "../middleaware/middleWare";
@Controller("/")
class FoodController {
  // 路由器接收参数
  @get("/showFood/:foodname/:address")
  @middleware(SecondMiddleAware)
  @middleware(isValidUser)
  showFood(req: Request, res: Response): void {
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    res.write("大混沌");
    res.write("一锅炖");
    // 使用参数
    res.write(req.params.foodname + req.params.address)
    res.end();
  }
}

```

```ts
// userController.ts
 // 跳转路由时传递参数
    res.write(`<div><a  href="/showFood/xiaolongxia/chengdu">进入美食首页</a></div>`);
```

