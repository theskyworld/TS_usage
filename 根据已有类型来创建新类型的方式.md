## 根据已有类型来创建新类型的方式

##### 索引访问类型

```ts
const symId = Symbol("productNum");

interface Product {
  [symId]: number | boolean;
  name: string;
  price: number;
  account: number;
  buy(): string;
  1: number | boolean;
  true : boolean;
}

// 索引访问类型
// 通过接口中的键类型来创建新的类型
// 通过接口的键来获取值的类型，并以此来创建一个新类型
type A = Product["price"]; // A的类型为number
type B = Product["price" | "name"]; // B的类型为string | number
//对于symbol类型的键，需要使用typeof来获取类型
type S = Product[typeof symId]; // S的类型为number | boolean
type F = Product["buy"]; // F的类型为() => string
type D = Product["1"]; // D的类型为number | boolean
type E = Product['true']; // E的类型为boolean

//使用keyof迭代Product中的所有键类型
type ProductKeys = keyof Product; //ProductKeys的类型为 "name" | "price" | "account" | "buy" | typeof symId
let prodocuKey1: ProductKeys = "account";
let prodocuKey2: "name" | "price" | "account" | "buy" | typeof symId = "buy";


interface Product {
  name: string;
  [symId]: number | boolean;
  price: number;
  account: number;
  buy(): string;
  "1": number;
  true: boolean;
  // 1: number; //不会被获取
}
type AllKeys<T> = T extends any ? T : never;
type ProductKeys2 = AllKeys<keyof Product>;

// 获取指定接口中所有键的类型
type InterfaceKeys<T> = T extends string | symbol ? T : never;
type ProductKeys = InterfaceKeys<keyof Product>;

// 获取指定对象中string类型键的类型
type InterfaceStringKeys<T> = T extends string ? T : never;
type ProductStringKeys = InterfaceStringKeys<keyof Product>;

```

##### 使用`keyof`

结合泛型约束

```ts
// 定义两个泛型，T约束于object，K约束于T的键类型
class ObjectRefImplement<T extends object, K extends keyof T> {
  public readonly __v_isRef: boolean = true;
  // 传入目标对象和键名作为参数
  constructor(private readonly _object: T, private readonly _key: K) {}
  // 根据传入的键名从传入的目标对象中取值
  get value() {
    return this._object[this._key];
  }
  // 根据传入的键名和在传入的目标对象中设置新值
  set value(newVal: T[K]) {
    this._object[this._key] = newVal;
  }
}

type Obj = {
    username: string;
    age: number;
}

// 从目标对象类型上获取指定的键类型
// 先判断的泛型K是否在泛型T对应的对象上，是则返回K，否则返回never(表示目标对象上不存在该键)
type GetPropKeyType<T extends object, K> = K extends keyof T ? K : never;
type ObjPropKey1 = GetPropKeyType<Obj, "username">;
// ObjPropKey1的值为"username"
type ObjPropKey2 = GetPropKeyType<Obj, "age">;
// ObjPropKey2的值为"age"

// 以此可以来获取目标对象上指定键的值类型
type GetPropValueType<T extends object, K> = K extends keyof T ? T[K] : never;
type ObjPropValue1 = GetPropValueType<Obj, 'username'>;
// ObjPropValue1的值为string
type ObjPropValue2 = GetPropValueType<Obj, 'age'>;
// ObjPropValue2的值为number

const obj: Obj = { "username": 'Alice', age: 12 }
const objectRefImplement = new ObjectRefImplement<Obj, "age">(obj, "age");
console.log(objectRefImplement.value); // 12
objectRefImplement.value = 11;
console.log(objectRefImplement.value); // 11

// 泛型的反向推导
// 自动根据"age"推导K出的具体类型为"age"
// 不需要手动指定<Obj, "age">
const obj: Obj = { "username": 'Alice', age: 12 }
const objectRefImplement = new ObjectRefImplement(obj, "age");
console.log(objectRefImplement.value); // 12

export {};
```

```ts
// 优化keyof
interface Person {
    name: string,
    age: number,
    gender : string,
}
// 默认情况下，无法直接显示KeysOfPerson的具体的类型
type KeysOfPerson = keyof Person;
// KeysOfPerson的值为keyof Person

// 现在进行优化
type GetObviousKeysTypes<T> = T extends string | symbol ? T : never;
type GetObviousKeysTypesForPerson = GetObviousKeysTypes<keyof Person>;
//  现在可以直接看到GetObviousKeysTypesForPerson的值为"name" | "age" | "gender"
```

##### 泛型递归

```ts
// P in keyof Interface1 递归Interface1中所有的键类型，然后将其赋值给P
interface Person {
  name: string,
  age : number,
}
type PersonKeyValue = {
  // P in keyof Person递归获取Person中所有键类型
  // Person[P]获取对应键的值类型
  [P in keyof Person]: Person[P];
};
// PersonKeyValue的值为
// {
//   name: string,
//   age : number,
// }
```

##### 使用`infer`

获取一个函数的参数和返回值类型

```ts
// 使用infer关键字获取一个函数的参数或者返回值类型
interface Person {
  name: string;
  age: number;
}
type PersonFunc = (param: Person) => number;


// 获取PersonFunc类型中参数的类型
// infer P为一个占位符，表示获取param的类型，并将其赋值给P
// 先进行条件判断PersonFunc extends (param: infer P) => number
// 判断(param: infer P) => number类型是否与PersonFunc类型相匹配
// 匹配则返回P，参数param的类型；否则，返回PersonFunc类型
type PersonFuncPram1 = PersonFunc extends (param: infer P) => number
  ? P
  : PersonFunc;
// 条件判断为true
// PersonFuncPram1的值为Person

// 获取PersonFunc类型中参数的类型
type PersonFuncPram2 = PersonFunc extends (param: infer P) => string
  ? P
  : PersonFunc;
// 条件判断为false
// PersonFuncPram2的值为 (param: Person) => number


// 同理，获取上述PersonFunc函数中返回值的类型
type PersonFuncPram2 = PersonFunc extends (param: infer R) => string
  ? R
  : PersonFunc;
// 条件判断为false
// PersonFuncPram2的值为 (param: Person) => number

// 通用式写法
type GetReturnType<T> = T extends (param: any) => infer R ? R : never;
type PersonReturn = GetReturnType<PersonFunc>;
// GetReturnType的值为number
```

获取一个数组中元素的类型

```ts
// 先进行条件判断，确保泛型T类型为一个数组，然后再进行元素类型的获取
type GetArrayElementType<T> = T extends Array<infer E> ? E : never;

type ArrayElement1 = GetArrayElementType<Array<number>>;
// ArrayElement1的值为number
type ArrayElement2 = GetArrayElementType<Array<{name : string, age : number}>>;
// ArrayElement2的值为
// {
//   name: string;
//   age: number;
// }
```

##### 使用`Extract`或`Exclude`或`Pick`

```ts
// Extract为底层提供的一个基本条件类型的简写
// 可以理解为从前者提取出所有后者中存在的类型
// type Extract<T, U> = T extends U ? T : never;
type TestExtract = Extract<string | number | boolean, string | number>; // TestExtract的值为string | number

// 即
type TestExtract1 =
  | Extract<string, string | number>
  | Extract<number, string | number>
  | Extract<boolean, string | number>;
// TestExtract1的值为string | number

// 以上等价于
type TestExtract2 =
  | (string extends string | number ? string : never)
  | (number extends string | number ? number : never)
  | (boolean extends string | number ? boolean : never);
// TestExtract2的值为string | number



// Exclude也是底层提供的一个基本条件类型的简写，并且其刚好相反于Extract
// 可以理解为从前者提取出所有后者中不存在的类型
// type Exclude<T, U> = T extends U ? never : T;
type TestExclude = Exclude<string | number | boolean, string | number>; // TestExclude的值为boolean
```

```ts
// Pick类型
// 抓取一个接口或者类中指定属性的键类型
// type Pick<T, K extends keyof T> = {
//   [P in K]: T[P];
// };

interface Person {
  name: string;
  age: number;
}
type SubPerson1 = Pick<Person, "name">;
// SubPerson1的值为
// {
//   name: string;
// }

type SubPerson2 = Pick<Person, "name" | "age">;
// SubPerson2的值为
// {
//   name: string;
//   age: number;
// }

```

