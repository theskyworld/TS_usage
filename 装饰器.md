## 装饰器

### 概述

#### 定义

装饰器是一个方法或者函数，可以注入（写入）到类、属性、方法、参数和对象上，扩展其功能

装饰器的本质就是通过装饰器函数的形参来获取使用装饰器目标对象（类、方法、属性、对象的原型、构造函数、属性描述符等），在对目标对象进行其逻辑执行的同时，在装饰器函数内对其扩展新的功能

#### 装饰器要解决的问题

解决在不修改原来类、方法、属性或者参数的前提下，为其添加新的业务需求功能。

例如为整个项目中的所有业务类（假如存在50个类）中的所有方法（假如存在6个方法）都增加展示日志信息的功能。如果逐个增加，则需要增加300次，但是通过装饰器，只需要增加一次即可。

例如在Nest.js中，装饰器可以解决依赖注入的问题，其中依赖注入以使用和创建分离为核心思想

#### 装饰器分类

- 类装饰器

- 属性装饰器

- 方法装饰器

- 参数装饰器

- 元数据装饰器

  

#### 装饰器的写法

- 使用（调用）时可以传递参数的装饰器（装饰器工厂）
- 使用时不可以传递参数的装饰器

### 装饰器的使用

环境搭建

- 安装`concurrently`，支持合并执行，可同时执行多个脚本文件；安装`nodeman`，监控指定的脚本文件，发生修改时，自动重新执行

  ```shell
  npm i concurrently -S
  npm i nodemon -S
  ```

- 修改`tsconfig.json`文件：

  ```json
  {
       // 便于看到脚本源码的底层逻辑
      "target": "ES5"
      // 消除装饰器警告
      //普通装饰器和元数据装饰器
  	"experimentalDecorators": true,
  	"emitDecoratorMetadata": true,
      // 指定输出文件的目录
      "outDir": "./dist", 
       // 指定源文件的根路径
      "rootDir": "./src",
  }
  ```

- 配置`package.json`文件：

  ```json
  "scripts": {
      // TS构建命令，将TS文件编译为JS文件，并进行监控，文件变化时，自动重新编译
      "dev:build" : "tsc -w",
      //使用nodemon，监控dist/teaching目录下的所有js文件，当文件发生变化时，自动重新执行node ./dist/teaching/classDecorator.js命令，便于在控制台中随时查看更新后的代码执行结果
  	"dev:start" : "nodemon --watch dist/teaching js  --exec node ./dist/teaching/classDecorator.js",
      //使用concurrently，合并执行"scripts"中的所有以dev:开头的命令
      "start": "concurrently npm:dev:*",
      //解决编译TS文件时，装饰器中出现的bug
      "tsc": "tsc src/teaching/classDecorator.ts --target ES5 -w --experimentalDecorators"
    },
  ```

#### 类装饰器

不带参数的装饰器：

```ts
// 定义一个装饰器，装饰器实质为一个函数
// 将在类上进行使用，类装饰器
// 使用该函数，对所有运用FirstClassDecorator装饰器的类进行指定的修改
//使用装饰器函数，获取目标对象，例如一个目标类，然后根据所需要添加的新需求一个API来扩展目标类
//例如对目标类的原型进行操作，对目标类的构造函数进行操作，对目标类的属性、方法、属性描述符等进行操作
function FirstClassDecorator(targetClass: any) {
  // 获取targetClass构造器的名字
  console.log(targetClass.prototype.constructor.name + "信息");
  // 获取类中方法的名字和方法的属性描述器
  Object.keys(targetClass.prototype).forEach((methodName) => {
    console.log("方法:", methodName);
    const dataProp = Object.getOwnPropertyDescriptor(
      targetClass.prototype,
      methodName
    );
    console.log("方法数据属性：", dataProp);
  });
  //   console.log(targetClass.name);
  //   const targetClassInstance = new targetClass();
  //   targetClassInstance.buy();
}

@FirstClassDecorator
class CustomerService {
  name: string = "下单";
  constructor() {}
  buy() {
    console.log(this.name + "购买");
  }
  placeOrder() {
    console.log(this.name + "下单购买");
  }
}

@FirstClassDecorator
class Person {
  uname: string = "Alice";
  constructor() {}
  sayHello() {
    console.log(this.uname + "say hello");
  }
}
```

带参数的装饰器：

```ts
// 带参数的装饰器
function FirstClassDecorator(params: string) {
    // console.log(params)
    return function (targetClass: any) {
        console.log(`${targetClass.name} : ${params}`)
    };
}

@FirstClassDecorator("param for CustomerService")
class CustomerService {
  name: string = "下单";
  constructor() {}
  buy() {
    console.log(this.name + "购买");
  }
  placeOrder() {
    console.log(this.name + "下单购买");
  }
}

@FirstClassDecorator("param for Person")
class Person {
  uname: string = "Alice";
  constructor() {}
  sayHello() {
    console.log(this.uname + "say hello");
  }
}
```

泛型工厂类继承装饰器

```ts
// 泛型工厂类继承装饰器
// 运用场景
// 对于一个已经开发好的项目，将其所有的类，增添这样的新功能：
// 在创建类的实例时，打印日志信息，输出哪一个类的实例被创建了，以及相应的参数信息

// 装饰器
// 将targetClass的原来类型any修改为一个更具体的类型(一个继承自类的泛型)
// { new(...args: any): any } 表示一个类的类型
function LogInfoDecorator<T extends { new (...args: any): any }>(
  targetClass: T
) {
  // 使用类继承来实现
  // 创建一个目标类的子类，继承自目标类
  // 然后在子类中实现所需求的功能，同时调用目标类的构造器
  class TargetClassSon extends targetClass {
    constructor(...args: any) {
      super(...args);

      // 添加新的所需求功能,对目标类的功能进行扩展
      //   console.log(
      //     `日志信息
      //     类 ${(targetClass as any).name} 被创建;
      //     传入的参数为[${args}]
      //     `
      //   );

      // 将以上内容封装到一个函数内
      LogInfo<T>(targetClass, ...args);
    }
  }
  // 将目标类返回，然后将其赋值给目标类
  // 源码中：Test = LogInfoDecorator()
  // 然后让new Test()创建Test的实例时,实际调用的是new TargetClassSon()
  // 这样既可以实现Test中的功能,创建一个Test实例,又可以实现新添加的所需求功能
  return TargetClassSon;
}

function LogInfo<T>(targetClass: T, ...args: any) {
  console.log(
    `日志信息
        类 ${(targetClass as any).name} 被创建;
        传入的参数为:[${args}]
        `
  );
}
// 测试类，使用上述的装饰器
@LogInfoDecorator
class Test {
  name: string;
  age!: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  eat() {
    console.log(this.name + "eating...");
  }
}
new Test("Alice", 12);
// 打印的内容为
// 日志信息
//   类 Test 被创建;
//   传入的参数为:[Alice,12]

```

结合匿名类使用：

```ts
function LogInfoDecorator<T extends { new (...args: any): any }>(
  targetClass: T
) {
  // 返回一个匿名类
  // 但是实际的底层源码中，会为该匿名类自动添加一个名字，例如Class_1
  return class extends targetClass {
    constructor(...args: any) {
      super(...args);
      LogInfo<T>(targetClass, ...args);
    }
  };
  //   return TargetClassSon;
}
```

#### 方法装饰器

不带参数的装饰器：

```ts
// 方法装饰器
// 不带参数的方法装饰器
/**
 * 快速生成函数参数注释的快捷键 : /** 回车
 * @param targetClassPrototype
 * @param methodName
 * @param methodDescription
 */
function MethodDecorator(
  targetClassPrototype: any,
  methodName: string,
  methodDescription: PropertyDescriptor
) {
  // 输出目标方法的原型,方法名,方法的属性描述符
  console.log("targetClassPrototype: ", targetClassPrototype);
  console.log("methodName: ", methodName);
  console.log("methodDescription: ", methodDescription);

  // 执行目标方法
  methodDescription.value();
}

class RoleService {
  public rolname: string = "administrator";
  constructor() {}

  // 目标方法
  @MethodDecorator
  describeRoles() {
    console.log("描述角色");
  }
}
```

带参数的装饰器：

```ts
// 带参数的方法装饰器
/**
 * 
 * @param MethodDecoratorParam 
 * @returns 
 */
function MethodDecorator(MethodDecoratorParam: string) {
  return function (
    targetClassPrototype: any,
    methodName: string,
    methodDescription: PropertyDescriptor
  ) {
    // 输出目标方法的原型,方法名,方法的属性描述符
    console.log("targetClassPrototype: ", targetClassPrototype);
    console.log("methodName: ", methodName);
    console.log("methodDescription: ", methodDescription);

    // 执行目标方法
    methodDescription.value();
    console.log(MethodDecoratorParam);
  };
}

// 目标方法
  @MethodDecorator("MethodDecoratorParam")
  describeRoles() {
    console.log("描述角色");
  }
```

使用方法装饰器实现一个方法的前置后置拦截器：

```ts
// 使用装饰器实现方法的前置和后置拦截器
function MethodInterceptorDecorator(params: string) {
  return function (
    targetClassPrototype: any,
    methodName: string,
    methodDescription: PropertyDescriptor
  ) {
    // 获取原来的目标方法
    const targetMethod = methodDescription.value;
    // 对目标方法进行扩展
    methodDescription.value = function (...args: any[]) {
      console.log("前置拦截...");
      targetMethod.apply(this, args);
      console.log("后置拦截...");
    };
  };
}


class Person {
  name: string = "Alice";
  constructor() {}

  @MethodInterceptorDecorator("xxx")
  sayHello() {
    console.log(this.name + " say hello");
  }
}
new Person().sayHello();
// 前置拦截...
// Alice say hello
// 后置拦截...
```

#### 属性装饰器

不带参数的属性装饰器

```ts
// 属性装饰器
// 带参数的属性装饰器
/**
 *
 * @param targetClassProperty
 * @param attrName
 */
function LoginPropertyDecorator(
  targetClassProperty: any,
  attrName: string | symbol
) {
  console.log("targetClassProperty: ", targetClassProperty);
  console.log("attrName: ", attrName);
}

class Person {
  name: string = "Alice";

  @LoginPropertyDecorator
  age: number = 12;

  constructor() {}
}
new Person();
```

带参数的属性装饰器

```ts
function LoginPropertyDecorator(params: any) {
  return function (targetClassProperty: any, attrName: string | symbol) {
    console.log("targetClassProperty: ", targetClassProperty);
    console.log("attrName: ", attrName);
  };
}
```

依赖注入属性装饰器，结合元数据进行使用

- 元数据是指为了帮助类、方法和属性装饰器实现一定的功能，而附在其上的一些数据。分为自定义的元数据和内置元数据

- 安装第三方包

  ```shell
  npm i reflect-metadata --save
  ```

- 进行使用

  ```ts
  import "reflect-metadata";
  type MyPropertyDecorator = (
    target: Object,
    propertyKey: string | symbol
  ) => void;
  
  // 依赖注入属性装饰器,内部返回一个属性装饰器
  function InjectDecorator(injectId?: string): MyPropertyDecorator {
    // 该装饰器函数参数和返回值的类型已经通过MyPropertyDecorator被定义
    return (targetClassProperty, propertyKey) => {
      console.log("进入依赖注入属性装饰器,inject");
      console.log("target:", targetClassProperty);
      console.log("propertyKey:", propertyKey);
      console.log("id : ", injectId);
  
      // 使用元数据
      // 使用元数据来获取当前依赖注入属性装饰器修饰的属性的类型
      // 如果不是一个构造函数或类,则会被强制转换为该类型的构造函数。例如number =》 [Function : Number]
      // 使用Reflect.getMetadata()方法获取内置的或者自定义的元数据
      const decoratedPropertyType = Reflect.getMetadata(
        "design:type",
        targetClassProperty,
        propertyKey
      );
      console.log(decoratedPropertyType); // decoratedPropertyType的值为Person类
      new decoratedPropertyType(); // "创建Person类的实例对象"
    };
  }
  
  // 测试
  class Person {
    constructor() {
      console.log("创建Person类的实例对象");
    }
  }
  
  class Controller {
    @InjectDecorator("injectId1")
    person?: Person;
    // person?: number;
  }
  ```

属性装饰器→方法装饰器→类装饰器的执行顺序：(由类或者对象的内部向外部执行（属性/方法→对象或者类）)

```ts
// 不同类型装饰器的执行顺序:属性装饰器→方法装饰器→类装饰器
//或者（属性和方法的执行顺序依据代码书写顺序）
// 方法装饰器→属性装饰器→类装饰器
import "reflect-metadata";
type MyMethodDecoratorType = (
  targetClassProperty: any,
  methodName: string,
  methodDescription: PropertyDecorator
) => void;

// 方法装饰器,结合元数据使用
function MethodDecorator(path: string): MyMethodDecoratorType {
  return function (targetClassProperty, methodName, methodDescription) {
    console.log("进入方法装饰器:", path);
    // 定义一个元数据
    Reflect.defineMetadata("path", path, targetClassProperty, methodName);
  };
}

// 类装饰器,结合元数据使用
function ClassDecorator(rootPath: string) {
  return function <T extends { new (...args: any): any }>(targetClass: T) {
    // console.log("targetClass : ", targetClass);
    Object.keys(targetClass.prototype).forEach((key) => {
      // 获取并打印上述方法装饰器中定义的元数据
      console.log(Reflect.getMetadata("path", targetClass.prototype, key));
    });
  };
}

// 属性装饰器,结合元数据使用
type MyPropertyDecorator = (
  target: Object,
  propertyKey: string | symbol
) => void;

function InjectDecorator(injectId?: string): MyPropertyDecorator {
  return (targetClassProperty, propertyKey) => {
    console.log("进入依赖注入属性装饰器,inject");
    const decoratedPropertyType = Reflect.getMetadata(
      "design:type",
      targetClassProperty,
      propertyKey
    );
  };
}

// 测试
class Person {}
@ClassDecorator("/Controller")
class Controller {
  @InjectDecorator("injectId1")
  person?: Person;
  @MethodDecorator("/sayHello")
  sayHello() {
    console.log("hello");
  }
}
```

#### 参数装饰器

普通函数参数装饰器：

```ts
// 普通函数参数装饰器
// 带参数
function UrlParam(params: any) {
  return function paramDecorator(
    targetClassPrototype: any,
    methodName: string,
    paramIndex: number
  ) {
    console.log("targetClassPrototype: ", targetClassPrototype);
    console.log("methodName: ", methodName);
    // paramIndex表示被修饰的参数的索引(从0开始)
    console.log("paramIndex: ", paramIndex);
  };
}

// 测试
class Person {
  // 使用UrlParam("hello")参数装饰器修饰第一个参数times
  sayHello(@UrlParam("hello") times: number) {
    console.log(`say hello ${times} times`);
  }
}
new Person().sayHello(3);

```

构造函数参数装饰器：

```ts
import "reflect-metadata";
type ParamDecorator = (
  target: Object,
  paramName: string | symbol,
  paramIndex: number
) => void;
// 构造函数参数装饰器
function InjectConstructor(injectId?: string): ParamDecorator {
  return (targetClass, paramName, paramIndex) => {
    console.log("targetClass : ", targetClass);
    console.log("paramName : ", paramName);
    console.log("paramIndex : ", paramIndex);

    // 使用元数据获取目标构造函数的所有参数的类型
    const constructorParamTypesArr = Reflect.getMetadata(
      "design:paramtypes",
      targetClass
    );
    console.log("constructorParamTypesArr : ", constructorParamTypesArr);

    // 结合paramIndex获取那个被参数装饰器修饰的参数的类型
    const targetParamType = constructorParamTypesArr[paramIndex];
    console.log("targetParamType : ", targetParamType); // [Function: Person] Person类(构造函数)
    new targetParamType(); // '创建Person类的实例对象'
  };
}

// 测试
class Person {
  constructor() {
    console.log("创建Person类的实例对象");
  }
}
class UserController {
  constructor(
    @InjectConstructor("userService") person: Person,
    count: string
  ) {}
}

```

结合单例设计模式使用：

```ts
import "reflect-metadata";
type ParamDecorator = (
  target: Object,
  paramName: string | symbol,
  paramIndex: number
) => void;

// 创建一个用于收集类实例对象的类
class CollectionInstanceOfClass<T = any> {
  static collection: CollectionInstanceOfClass =
    new CollectionInstanceOfClass();

  private containerMap = new Map<string | symbol, any>();

  private constructor() {
    console.log("创建CollectionInstanceOfClass类的实例对象...");
  }
  private static test() {
    console.log("test...");
  }

  public set(id: string | symbol, value: T): void {
    this.containerMap.set(id, value);
  }
  public get(id: string | symbol): T {
    return this.containerMap.get(id);
  }
}
// 获取CollectionInstanceOfClass类的实例
const collectionInstance = CollectionInstanceOfClass.collection;
// 构造函数参数装饰器
function InjectConstructor(injectId?: string): ParamDecorator {
  return (targetClass, paramName, paramIndex) => {
    // 使用元数据获取目标构造函数的所有参数的类型
    const constructorParamTypesArr = Reflect.getMetadata(
      "design:paramtypes",
      targetClass
    );
    console.log("constructorParamTypesArr : ", constructorParamTypesArr);

    // 结合paramIndex获取那个被参数装饰器修饰的参数的类型
    const targetParamType = constructorParamTypesArr[paramIndex];
    console.log("targetParamType : ", targetParamType); // [Function: Person] Person类(构造函数)
    // 创建Person类的实例对象
    const targetParamTypeInstance = new targetParamType(); //
    // 将目标参数类型的实例存入到collectionInstance中
    collectionInstance.set(injectId!, targetParamTypeInstance);
  };
}

// 测试
class Person {
  name: string = "Alice";
  constructor() {
    console.log("创建Person类的实例对象");
  }
  login() {
    console.log(this.name + " 登录...");
  }
}
class UserController {
  constructor(
    @InjectConstructor("personService") person: Person,
    count: string
  ) {}

  public login() {
    const personServiceInstance = collectionInstance.get("personService");
    // 调用Person类实例上的login方法
    personServiceInstance.login(); // 'Alice 登录...'
  }
}

const userControler = new UserController(new Person(), "111");
userControler.login();
```

类、属性、方法、参数装饰器执行顺序：(由类或者对象的内部向外部执行（属性/方法→对象或者类）)

```ts
// 属性装饰器→普通函数参数装饰器→第一个方法装饰器→普通函数参数装饰器→第二个方法装饰器→...→构造函数参数装饰器→类装饰器
// 或者(属性和方法的执行顺序依据代码的书写顺序决定)
// 普通函数参数装饰器→第一个方法装饰器→属性装饰器→普普通函数参数装饰器→第二个方法装饰器→...→构造函数参数装饰器→类装饰器
// 方法装饰器
/**
 *
 * @param targetClassPrototype
 * @param methodName
 */
function FirstMethodDecorator(targetClassPrototype: any, methodName: string) {
  console.log("---------执行第一个方法装饰器-----------");
  console.log("类名:", targetClassPrototype);
  console.log("方法名:", methodName);
}

/**
 *
 * @param params
 * @returns
 */
function SecondMethodDecorator(params: string) {
  return function (targetClassPrototype: any, methodName: string) {
    console.log("---------执行第二个方法装饰器-----------");
    console.log("类名:", targetClassPrototype);
    console.log("方法名:", methodName);
  };
}

/**
 *
 * @param targetClassPrototype
 * @param paramName
 * @param paramIndex
 */
// 普通函数参数装饰器
function ParamDecorator(
  targetClassPrototype: any,
  paramName: string,
  paramIndex: number
) {
  console.log("---------执行普通函数参数装饰器-----------");
  console.log("targetClassPrototype:", targetClassPrototype);
  console.log("paramName:", paramName);
  console.log("paramIndex:", paramIndex);
}

// 构造函数参数装饰器
/**
 *
 * @param params
 * @returns
 */
function ConstructorParamDecorator(params: any) {
  return function (
    targetClassPrototype: any,
    paramName: string | undefined,
    paramIndex: number
  ) {
    console.log("---------执行构造函数参数装饰器-----------");
    console.log("targetClassPrototype:", targetClassPrototype);
    console.log("paramName:", paramName);
    console.log("paramIndex:", paramIndex);
  };
}

/**
 *
 * @param targetClassPrototype
 * @param attrName
 */
// 属性装饰器
function AttrDecorator(targetClassPrototype: any, attrName: any) {
  console.log("---------执行属性装饰器-----------");
  console.log("targetClassPrototype:", targetClassPrototype);
  console.log("attrName:", attrName);
}

// 类装饰器
/**
 *
 * @param targetClassPrototype
 */
function ClassDecorator(targetClassPrototype: any) {
  console.log("---------执行类装饰器-----------");
  console.log("targetClassPrototype: ", targetClassPrototype);
}

// 测试
@ClassDecorator
class URLInfo {
  @AttrDecorator
  baseUrl: string = "https://www.baidu.com";
  constructor(@ConstructorParamDecorator("url") public url: string) {}

  @FirstMethodDecorator
  methodOne(@ParamDecorator data: string) {
    console.log(data);
  }

  @SecondMethodDecorator("method2")
  methodTwo(@ParamDecorator address: string) {
    console.log(address);
  }
}

```

### 元数据

#### 概述

元数据是指附加在对象、类、方法、属性和参数上的数据

目的是用来帮助实现某种业务功能

#### 基本使用

通过调用`Reflect`的各种方法来进行使用

`targetClass | targetObj`目标类或者目标对象

`targetPrototype`存在该目标属性或者目标方法的对象

- 类或者对象中

  - 为类或者对象定义元数据：`Reflect.defineMetadata(metaKey, metaValue, targetClass | targetObj)`

  - 获取类或者对象中的元数据(可用于获取内置或者自定义的元数据)：`Reflect.getMetadata(metaKey, targetObj);`

- 方法中

  - 为方法定义元数据：`Reflect.defineMetadata(metaKey, metaValue, targetPrototype, methodName);`

  - 获取方法中的元数据：`Reflect.getMetadata(metaKey, targetPrototype, methodName)`

- 属性中

  - 为属性定义元数据：`Reflect.defineMetadata(metaKey, metaValue, targetPrototype, attrName);`

  - 获取属性中的元数据：`Reflect.getMetadata(metaKey, targetPrototype, attrName)`

- 查看对象或类,属性,方法中是否存在某个元数据（会从原型链中查找）

  - `Reflect.hasMetadata("metaKey", targetObj | targetClass);`

  - `Reflect.hasMetadata("metaKey", targetPrototype, attrName | methodName);`

- 查看对象或类,属性,方法自身中是否存在某个元数据（不会从原型链中查找）

  - `Reflect.hasOwnMetadata("metaKey", targetObj | targetClass);`

  - `Reflect.hasOwnMetadata("metaKey", targetPrototype, attrName | methodName);`

安装`reflect-metadata`

```shell
npm i reflect-metadata --save
```

进行使用

```ts
import "reflect-metadata";

const obj = {
  userName: "Alice",
  age: 12,
  showInfo() {
    console.log("infos about" + this.userName);
  },
};
class Person {
  name: string = "Alice";
  constructor() {}
  sayHello() {}
}
// 对象上
// 定义元数据
Reflect.defineMetadata("metaKey1", "metaValue1", obj);
// 获取元数据
console.log(Reflect.getMetadata("metaKey1", obj)); // "metaValue1"

// 属性上
Reflect.defineMetadata("metaKey2", "metaValue2", obj, "userName");
console.log(Reflect.getMetadata("metaKey2", obj, "userName")); // "metaValue2"
Reflect.defineMetadata("metaKey2", "metaValue2", Person, "name");
console.log(Reflect.getMetadata("metaKey2", Person, "name")); // "metaValue2"

// 方法上
Reflect.defineMetadata("metaKey3", "metaValue3", obj, "showInfo");
console.log(Reflect.getMetadata("metaKey3", obj, "showInfo")); // "metaValue3"
Reflect.defineMetadata("metaKey3", "metaValue3", Person, "sayHello");
console.log(Reflect.getMetadata("metaKey3", Person, "sayHello")); // "metaValue3"

// 类上
Reflect.defineMetadata("metaKey4", "metaValue4", Person);
console.log(Reflect.getMetadata("metaKey4", Person)); // "metaValue4"

```

```ts
import "reflect-metadata";
class Person {
  @Reflect.metadata("metaKey1", "metaValue1")
  name: string = "Alice";
}

class PersonSub extends Person {
  age: number = 12;
}

console.log(Reflect.hasMetadata("metaKey1", PersonSub.prototype, "name")); // true
console.log(Reflect.hasOwnMetadata("metaKey1", PersonSub.prototype, "name")); // false
```

或者定义时,直接使用装饰器进行定义：

```ts
import "reflect-metadata";
// 或者定义时,直接使用装饰器进行定义
@Reflect.metadata("metaKey1", "metaValue1")
class Person {
  @Reflect.metadata("metaKey2", "metaValue2")
  name: string = "Alice";
  constructor() {}
  @Reflect.metadata("metaKey3", "metaValue3")
  sayHello() {}
}

console.log(Reflect.getMetadata("metaKey1", Person)); // "metaValue1"
//获取属性或者方法上的元数据时，在类的构造器原型上获取
console.log(Reflect.getMetadata("metaKey2", Person.prototype, "name")); // "metaValue2"
console.log(Reflect.getMetadata("metaKey3", Person.prototype, "sayHello")); // "metaValue3"

```

`Reflect.getMetadataKeys()、Reflect.getOwnMetadataKeys()`：

```ts
import "reflect-metadata";

@Reflect.metadata("info", "地球人")
class Person {
  firstname: string = "Dan";
  lastname: string = "Alice";
  @Reflect.metadata("describe", "居住地主要为城市")
  place: string = "中国 北京";

  @Reflect.metadata("firstname", "姓")
  @Reflect.metadata("lastname", "名")
  getFullName(name: string): string {
    return this.firstname + " " + this, this.lastname;
  }
}

// 获取getFullName上所有的metaKey,包括内置和自定义的
console.log(Reflect.getMetadataKeys(Person.prototype, "getFullName"));
// [
//   "design:returntype", // 描述方法返回值类型
//   "design:paramtypes", // 描述方法参数类型,值放在一个数组中
//   "design:type", // 描述方法类型
//   "lastname",
//   "firstname",
// ];

// 根据metaKey遍历获取metaValue
Reflect.getMetadataKeys(Person.prototype, "getFullName").forEach((key) => {
  console.log(Reflect.getMetadata(key, Person.prototype, "getFullName"));
  // [Function: String]
  // [ [Function: String] ]
  // [Function: Function]
  // 名
  // 姓
});

```

获取`metaValue`时，`metaKey`相同不会覆盖，因为还由`targetPrototype`进行决定（在不同对象中）

```ts
import "reflect-metadata";

@Reflect.metadata('metaKey1', 'metaValue1')
class Person1 {
  name: string = "Alice";
}

@Reflect.metadata("metaKey1", "metaValue2")
class Person2 {
  age: number = 12;
}

// 获取同metaKey的元数据
console.log(Reflect.getMetadata('metaKey1', Person1)); // "metaValue1"
console.log(Reflect.getMetadata("metaKey1", Person2)); // "metaValue2
```

#### 常用的内置修饰器的`metaKey`]

##### `design:type`

获取类中属性的类型

```ts
import "reflect-metadata";
class Person {
  @AttrTypeDecorator
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = "Alice";
    this.age = 12;
  }

  sayHello(times: number) {
    console.log(`${this.name} say hello for ${times} times!`);
  }
}

function AttrTypeDecorator(
  targetClassProperty: object,
  attrName: string | symbol
) {
  console.log(
    Reflect.getMetadata("design:type", targetClassProperty, attrName)
  ); // [Function: String]
}
```

##### `design:paramtypes`

- 获取构造器函数中所有参数类型组成的数组
- 获取类中指定方法所有参数类型组成的数组

```ts
import "reflect-metadata";
class Person {
  name: string;
  age: number;

  constructor(@ConstructorParamsTypesDecorator name: string, age: number) {
    this.name = "Alice";
    this.age = 12;
  }
  sayHello(@ParamsTypesDecorator times: number) {
    console.log(`${this.name} say hello for ${times} times!`);
  }
}

function ConstructorParamsTypesDecorator(
  targetClass: { new (...args: any): any },
  paramName: string,
  paramIndex: number
) {
  console.log(Reflect.getMetadata("design:paramtypes", targetClass)); // [ [Function: String], [Function: Number] ]
}

function ParamsTypesDecorator(
  targetPrototype: object,
  methodName: string,
  paramIndex: number
) {
  console.log(
    Reflect.getMetadata("design:paramtypes", targetPrototype, methodName)
  ); // [ [Function: Number] ]
}

```

##### `design:returntype`

获取类方法返回值的类型

```ts
import "reflect-metadata";
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = "Alice";
    this.age = 12;
  }
  @ReturnTypeDecorator
  sayHello(times: number): number {
    console.log(`${this.name} say hello for ${times} times!`);
    return 123;
  }
}

function ReturnTypeDecorator(targetPrototype: object, methodName: string) {
  console.log(
    Reflect.getMetadata("design:returntype", targetPrototype, methodName)
  ); // [ [Function: Number] ]
}
```



